<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GPU Benchmark: WebGL Universe (Fixed)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
    </style>
</head>
<body>

    <!-- Shaders -->
    <script id="vertexShader" type="x-shader/x-vertex">
        attribute float aSize;
        attribute vec3 aColor;
        varying vec3 vColor;
        void main() {
            vColor = aColor;
            vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
            gl_PointSize = aSize * ( 200.0 / -mvPosition.z );
            gl_Position = projectionMatrix * mvPosition;
        }
    </script>
    <script id="fragmentShader" type="x-shader/x-fragment">
        varying vec3 vColor;
        void main() {
            float r = distance(gl_PointCoord, vec2(0.5, 0.5));
            if (r > 0.5) {
                discard;
            }
            float alpha = 1.0 - smoothstep(0.4, 0.5, r);
            gl_FragColor = vec4(vColor * alpha, alpha);
        }
    </script>

    <!-- Main application script -->
    <script type="module">
        // TẤT CẢ CÁC IMPORT ĐỀU SỬ DỤNG PHIÊN BẢN MODULE TỪ CDN
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js';
        import { EffectComposer } from 'https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/postprocessing/UnrealBloomPass.js';
        import GUI from 'https://cdn.jsdelivr.net/npm/lil-gui@0.19.2/dist/lil-gui.esm.js';

        let camera, scene, renderer, composer, gui;
        let particles, geometry, material;

        const params = {
            particleCount: 500000,
            particleSize: 0.5,
            bloomEnabled: true,
            bloomThreshold: 0,
            bloomStrength: 1.5,
            bloomRadius: 0.5
        };

        init();
        animate();

        function init() {

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 10;

            renderer = new THREE.WebGLRenderer();
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            createParticles();
            
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                params.bloomStrength,
                params.bloomRadius,
                params.bloomThreshold
            );

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            setupGUI(bloomPass);

            window.addEventListener('resize', onWindowResize);
        }

        function createParticles() {
            if (particles) {
                scene.remove(particles);
                geometry.dispose();
                material.dispose();
            }

            geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const sizes = [];
            const color = new THREE.Color();

            for (let i = 0; i < params.particleCount; i++) {
                const x = THREE.MathUtils.randFloatSpread(100);
                const y = THREE.MathUtils.randFloatSpread(100);
                const z = THREE.MathUtils.randFloatSpread(100);
                positions.push(x, y, z);

                color.setHSL(0.5 + 0.5 * Math.random(), 1.0, 0.5 + 0.5 * Math.random());
                colors.push(color.r, color.g, color.b);

                sizes.push(params.particleSize * (0.5 + Math.random()));
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('aColor', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('aSize', new THREE.Float32BufferAttribute(sizes, 1));

            material = new THREE.ShaderMaterial({
                vertexShader: document.getElementById('vertexShader').textContent,
                fragmentShader: document.getElementById('fragmentShader').textContent,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthTest: false,
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }
        
        function setupGUI(bloomPass) {
            if (gui) gui.destroy();
            gui = new GUI();
            gui.title('GPU Benchmark Controls');

            const particleFolder = gui.addFolder('Particles');
            particleFolder.add(params, 'particleCount', 1000, 2000000, 1000).onChange(createParticles).name('Particle Count');
            
            const sizeController = particleFolder.add(params, 'particleSize', 0.1, 5).name('Base Size');
            sizeController.onChange(value => {
                const sizes = geometry.attributes.aSize.array;
                for (let i = 0; i < sizes.length; i++) {
                    sizes[i] = value * (0.5 + Math.random());
                }
                geometry.attributes.aSize.needsUpdate = true;
            });

            const bloomFolder = gui.addFolder('Bloom Effect');
            bloomFolder.add(params, 'bloomEnabled').onChange(value => composer.passes[1].enabled = value).name('Enable Bloom');
            bloomFolder.add(params, 'bloomStrength', 0.0, 3.0, 0.1).onChange(value => bloomPass.strength = value).name('Strength');
            bloomFolder.add(params, 'bloomRadius', 0.0, 1.0, 0.01).onChange(value => bloomPass.radius = value).name('Radius');
            bloomFolder.add(params, 'bloomThreshold', 0.0, 1.0, 0.01).onChange(value => bloomPass.threshold = value).name('Threshold');
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
        }
    </script>
</body>
</html>