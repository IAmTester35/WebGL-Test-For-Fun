<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Thiên hà hủy diệt GPU</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script type="importmap">
        {
            "imports": {
                "three": "https://esm.run/three",
                "three/addons/": "https://esm.run/three/addons/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        let scene, camera, renderer, controls, galaxy, composer, clock;

        // --- SHADERS ---
        const vertexShader = `
            uniform float uTime;
            uniform float uSize;

            attribute float aScale;
            attribute vec3 aRandomness;

            varying vec3 vColor;

            void main() {
                vec4 modelPosition = modelMatrix * vec4(position, 1.0);

                // Thêm dao động dọc theo trục Y cho mỗi hạt
                float timeFactor = uTime * aRandomness.x * 0.5;
                modelPosition.y += sin(timeFactor) * aRandomness.y * 0.15;

                vec4 viewPosition = viewMatrix * modelPosition;
                vec4 projectedPosition = projectionMatrix * viewPosition;
                gl_Position = projectedPosition;

                // Kích thước hạt, có hiệu ứng "phập phồng" nhẹ
                float sizeWobble = sin(timeFactor * 2.0) * 0.2 + 0.8;
                gl_PointSize = uSize * aScale * sizeWobble;
                
                // Bù trừ cho phối cảnh (hạt ở xa nhỏ hơn)
                gl_PointSize *= (1.0 / -viewPosition.z);

                vColor = color;
            }
        `;

        const fragmentShader = `
            varying vec3 vColor;
            uniform float uTime;
            
            // Lấy từ vertex shader, dù không khai báo, Three.js tự hiểu
            // attribute vec3 aRandomness; 

            void main() {
                // Tạo hạt hình tròn, mờ dần ở viền
                float distanceToCenter = distance(gl_PointCoord, vec2(0.5));
                float strength = 1.0 - (distanceToCenter * 2.0);
                strength = pow(strength, 2.0); // Làm cho tâm sáng hơn và viền mờ nhanh hơn

                // Hiệu ứng lấp lánh
                // float twinkle = sin(uTime * aRandomness.z * 5.0) * 0.5 + 0.5;
                // twinkle = pow(twinkle, 15.0); // Tăng power để chỉ có những lúc sáng chói, còn lại thì mờ

                vec3 finalColor = vColor * strength; // * (twinkle + 0.2);
                
                gl_FragColor = vec4(finalColor, strength);
            }
        `;

        function init() {
            clock = new THREE.Clock();

            // Scene
            scene = new THREE.Scene();

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(4, 5, 7);
            scene.add(camera);

            // Renderer
            const canvas = document.createElement('canvas');
            document.body.appendChild(canvas);
            renderer = new THREE.WebGLRenderer({
                canvas: canvas,
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.4;

            // Create Galaxy
            createGalaxy();

            // Post Processing (Hậu xử lý)
            composer = new EffectComposer(renderer);
            const renderPass = new RenderPass(scene, camera);
            composer.addPass(renderPass);

            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                1.0, // strength: Độ mạnh của hiệu ứng lóe sáng
                0.1, // radius: Bán kính của vầng sáng
                0.9  // threshold: Ngưỡng độ sáng, chỉ những pixel sáng hơn ngưỡng này mới lóe
            );
            composer.addPass(bloomPass);

            // Handle Resize
            window.addEventListener('resize', onWindowResize, false);
        }

        function createGalaxy() {
            const parameters = {
                count: 300000,
                size: 25.0, // Kích thước này giờ được điều khiển bởi uSize trong shader
                radius: 10,
                branches: 7,
                spin: 1.2,
                randomness: 0.8,
                randomnessPower: 4,
                insideColor: '#ff6030',
                middleColor: '#ff9c3a',
                outsideColor: '#3c65c4'
            };

            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(parameters.count * 3);
            const colors = new Float32Array(parameters.count * 3);
            const scales = new Float32Array(parameters.count);
            const randomness = new Float32Array(parameters.count * 3); // Dùng cho các hiệu ứng ngẫu nhiên trong shader


            const colorInside = new THREE.Color(parameters.insideColor);
            const colorMiddle = new THREE.Color(parameters.middleColor);
            const colorOutside = new THREE.Color(parameters.outsideColor);

            for (let i = 0; i < parameters.count; i++) {
                const i3 = i * 3;

                // Position
                const radius = Math.random() * parameters.radius;
                const spinAngle = radius * parameters.spin;
                const branchAngle = ((i % parameters.branches) / parameters.branches) * Math.PI * 2;

                const randomX = Math.pow(Math.random(), parameters.randomnessPower) * (Math.random() < 0.5 ? 1 : -1) * parameters.randomness * radius;
                const randomY = Math.pow(Math.random(), parameters.randomnessPower) * (Math.random() < 0.5 ? 1 : -1) * parameters.randomness * 0.4;
                const randomZ = Math.pow(Math.random(), parameters.randomnessPower) * (Math.random() < 0.5 ? 1 : -1) * parameters.randomness * radius;

                positions[i3 + 0] = Math.cos(branchAngle + spinAngle) * radius + randomX;
                positions[i3 + 1] = randomY;
                positions[i3 + 2] = Math.sin(branchAngle + spinAngle) * radius + randomZ;
                
                // Color
                const mixedColor = new THREE.Color();
                const lerpFactor = radius / parameters.radius;
                if (lerpFactor < 0.5) {
                    mixedColor.copy(colorInside).lerp(colorMiddle, lerpFactor * 2);
                } else {
                    mixedColor.copy(colorMiddle).lerp(colorOutside, (lerpFactor - 0.5) * 2);
                }
                colors[i3 + 0] = mixedColor.r;
                colors[i3 + 1] = mixedColor.g;
                colors[i3 + 2] = mixedColor.b;

                // Thêm các thuộc tính ngẫu nhiên cho shader
                scales[i] = Math.random() * 1.5 + 0.5;
                randomness[i3 + 0] = Math.random(); // Dùng cho tốc độ dao động
                randomness[i3 + 1] = Math.random(); // Dùng cho biên độ dao động
                randomness[i3 + 2] = Math.random(); // Dùng cho tốc độ lấp lánh (nếu bật)
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('aScale', new THREE.BufferAttribute(scales, 1));
            geometry.setAttribute('aRandomness', new THREE.BufferAttribute(randomness, 3));


            // Material
            const material = new THREE.ShaderMaterial({
                depthWrite: false,
                blending: THREE.AdditiveBlending,
                vertexColors: true,
                uniforms: {
                    uTime: { value: 0 },
                    uSize: { value: parameters.size }
                },
                vertexShader: vertexShader,
                fragmentShader: fragmentShader
            });

            // Points
            galaxy = new THREE.Points(geometry, material);
            scene.add(galaxy);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            composer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        }

        function animate() {
            const elapsedTime = clock.getElapsedTime();
            
            // Cập nhật uniform time cho shader
            galaxy.material.uniforms.uTime.value = elapsedTime;

            // Xoay nhẹ toàn bộ thiên hà (ngoài chuyển động của từng hạt)
            galaxy.rotation.y = elapsedTime * 0.05;

            controls.update();

            // Render bằng composer thay vì renderer
            composer.render();

            requestAnimationFrame(animate);
        }

        init();
        animate();
    </script>
</body>
</html>