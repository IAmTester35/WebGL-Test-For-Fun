<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lưới Lượng Tử Tương Tác</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
        }
    </style>
</head>

<body>
    <script>
        let particles = [];
        let flowfield;
        let hueValue = 0;
        const flowfieldScale = 200; // Độ chi tiết của dòng chảy
        let zoff = 0; // Chiều thứ 3 của Perlin noise để tạo hiệu ứng chảy

        function setup() {
            createCanvas(windowWidth, windowHeight);
            // Sử dụng hệ màu HSB để dễ dàng thay đổi màu sắc
            colorMode(HSB, 360, 100, 100, 1);
            background(0);

            // Khởi tạo flowfield
            flowfield = new Array(floor(width / flowfieldScale) * floor(height / flowfieldScale));
        }

        function draw() {
            // Nền đen mờ tạo hiệu ứng vệt sáng dài hơn
            background(0, 0.1);

            // Cập nhật và hiển thị flowfield (dòng chảy)
            let yoff = 0;
            for (let y = 0; y < floor(height / flowfieldScale); y++) {
                let xoff = 0;
                for (let x = 0; x < floor(width / flowfieldScale); x++) {
                    let index = x + y * floor(width / flowfieldScale);
                    let angle = noise(xoff, yoff, zoff) * TWO_PI * 4;
                    let v = p5.Vector.fromAngle(angle);
                    v.setMag(1);
                    flowfield[index] = v;
                    xoff += 0.1;
                }
                yoff += 0.1;
            }
            zoff += 0.005; // Làm cho dòng chảy thay đổi theo thời gian

            // Cập nhật và hiển thị các hạt
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].follow(flowfield);
                particles[i].update();
                particles[i].display();
                if (particles[i].isDead()) {
                    particles.splice(i, 1); // Xóa hạt đã chết
                }
            }

            // Cập nhật giá trị màu sắc chung
            hueValue = (hueValue + 0.5) % 360;
        }

        // Khi kéo chuột, tạo ra một "vụ nổ" hạt mới
        function mouseDragged() {
            for (let i = 0; i < 5; i++) {
                particles.push(new Particle(mouseX, mouseY, hueValue));
            }
        }

        class Particle {
            constructor(x, y, hue) {
                this.pos = createVector(x, y);
                this.vel = p5.Vector.random2D().mult(random(2, 5));
                this.acc = createVector(0, 0);
                this.maxSpeed = 4;
                this.lifespan = 255;
                this.hue = hue + random(-10, 10);
            }

            update() {
                this.vel.add(this.acc);
                this.vel.limit(this.maxSpeed);
                this.pos.add(this.vel);
                this.acc.mult(0); // Reset gia tốc
                this.lifespan -= 1.5;
            }

            applyForce(force) {
                this.acc.add(force);
            }

            // Tìm vector trong flowfield và đi theo nó
            follow(vectors) {
                let x = floor(this.pos.x / flowfieldScale);
                let y = floor(this.pos.y / flowfieldScale);
                let index = x + y * floor(width / flowfieldScale);
                let force = vectors[index];
                this.applyForce(force);
            }

            display() {
                let alpha = map(this.lifespan, 0, 255, 0, 1);

                // Hiệu ứng Bloom/Glow
                // Vầng sáng bên ngoài
                noStroke();
                fill(this.hue, 80, 100, alpha * 0.1);
                ellipse(this.pos.x, this.pos.y, 20);

                // Lõi sáng
                fill(this.hue, 80, 100, alpha * 0.8);
                ellipse(this.pos.x, this.pos.y, 4);
            }

            isDead() {
                return this.lifespan < 0;
            }

            checkEdges() { // Hiện không dùng nhưng giữ lại để có thể dùng sau
                if (this.pos.x > width || this.pos.x < 0 || this.pos.y > height || this.pos.y < 0) {
                    this.lifespan = 0;
                }
            }
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
        }
    </script>
</body>

</html>