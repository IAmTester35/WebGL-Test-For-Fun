<!DOCTYPE html>
<html>
<head>
    <title>Three.js - Quốc kỳ Tung bay (Chuẩn)</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.148.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.148.0/examples/jsm/"
        }
    }
    </script>

    <!-- Vertex Shader và Fragment Shader không thay đổi -->
    <script type="x-shader/x-vertex" id="flagVertexShader">
        uniform float uTime;
        uniform vec2 uFrequency;
        uniform float uAmplitude;
        varying vec2 vUv;
        void main() {
            vec3 pos = position;
            vUv = uv;
            float waveX = sin(pos.x * uFrequency.x + uTime * 2.0) * uAmplitude;
            float waveY = sin(pos.y * uFrequency.y + uTime * 1.5) * uAmplitude * 0.5;
            pos.z = (waveX + waveY) * uv.x;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
        }
    </script>
    <script type="x-shader/x-fragment" id="flagFragmentShader">
        uniform sampler2D uTexture;
        varying vec2 vUv;
        void main() {
            vec4 textureColor = texture2D(uTexture, vUv);
            gl_FragColor = textureColor;
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';

        // --- Thiết lập cơ bản (không đổi) ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(5, 5, 5);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.target.set(0, 3.5, 0);

        // --- Ánh sáng (không đổi) ---
        new RGBELoader().load('https://unpkg.com/three@0.148.0/examples/textures/equirectangular/venice_sunset_1k.hdr', (texture) => {
            texture.mapping = THREE.EquirectangularReflectionMapping;
            scene.background = texture;
            scene.environment = texture;
        });
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
        directionalLight.position.set(10, 10, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.set(1024, 1024);
        scene.add(directionalLight);
        
        // --- 3. Tạo Texture Cờ Việt Nam bằng Canvas (ĐÃ SỬA LỖI) ---
        function createVietnamFlagTexture() {
            const canvas = document.createElement('canvas');
            const width = 512;
            const height = width * 2 / 3;
            canvas.width = width;
            canvas.height = height;
            const context = canvas.getContext('2d');

            // Vẽ nền đỏ
            context.fillStyle = '#DA251D';
            context.fillRect(0, 0, width, height);

            // Vẽ ngôi sao vàng (PHIÊN BẢN SỬA LỖI)
            context.fillStyle = '#FFFF00';
            context.beginPath();

            const centerX = width / 2;
            const centerY = height / 2;
            const outerRadius = width / 5;
            const innerRadius = outerRadius / 2.5;
            const numPoints = 5;
            
            // Bắt đầu từ đỉnh trên cùng của ngôi sao (-90 độ)
            let rotation = Math.PI / 2 * 3;
            let x, y;

            for (let i = numPoints * 2; i > 0; i--) {
                // Sử dụng bán kính ngoài cho đỉnh, bán kính trong cho chỗ lõm
                const radius = (i % 2 === 0) ? outerRadius : innerRadius;
                
                x = centerX + Math.cos(rotation) * radius;
                y = centerY + Math.sin(rotation) * radius;

                if (i === numPoints * 2) {
                    context.moveTo(x, y);
                } else {
                    context.lineTo(x, y);
                }
                
                // Xoay một góc để đến điểm tiếp theo
                rotation += Math.PI / numPoints;
            }

            context.closePath();
            context.fill();

            return new THREE.CanvasTexture(canvas);
        }

        // --- Tạo các đối tượng (không đổi) ---
        const poleGeometry = new THREE.CylinderGeometry(0.1, 0.1, 7, 32);
        const poleMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 0.8, roughness: 0.2 });
        const pole = new THREE.Mesh(poleGeometry, poleMaterial);
        pole.position.y = 2.8;
        pole.castShadow = true;
        scene.add(pole);
        const flagGeometry = new THREE.PlaneGeometry(3, 2, 50, 50);
        const flagMaterial = new THREE.ShaderMaterial({
            vertexShader: document.getElementById('flagVertexShader').textContent,
            fragmentShader: document.getElementById('flagFragmentShader').textContent,
            uniforms: {
                uTime: { value: 0 },
                uFrequency: { value: new THREE.Vector2(4.0, 2.0) },
                uAmplitude: { value: 0.3 },
                uTexture: { value: createVietnamFlagTexture() }
            },
            side: THREE.DoubleSide,
            transparent: true
        });
        const flag = new THREE.Mesh(flagGeometry, flagMaterial);
        flag.position.set(1.5, 5, 0);
        flag.castShadow = true;
        scene.add(flag);
        const ground = new THREE.Mesh(new THREE.PlaneGeometry(20, 20), new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.8 }));
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // --- Vòng lặp Animation (không đổi) ---
        const clock = new THREE.Clock();
        function animate() {
            const elapsedTime = clock.getElapsedTime();
            flagMaterial.uniforms.uTime.value = elapsedTime;
            controls.update();
            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        animate();
    </script>
</body>
</html>