<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="100%" height="100%" viewBox="0 0 1600 900" style="background: radial-gradient(circle, #0a0e23 0%, #02010a 100%); cursor: none;">
  <defs>
    <filter id="glow">
      <feGaussianBlur stdDeviation="7" result="coloredBlur"/>
      <feMerge>
        <feMergeNode in="coloredBlur"/>
        <feMergeNode in="SourceGraphic"/>
      </feMerge>
    </filter>
    <radialGradient id="cursorGradient">
        <stop offset="0%" stop-color="rgba(255,255,255,0.8)" />
        <stop offset="100%" stop-color="rgba(0, 255, 255, 0)" />
    </radialGradient>
  </defs>

  <!-- Các lớp để tạo hiệu ứng Parallax 3D -->
  <g id="layer-far"></g>
  <g id="layer-mid"></g>
  <g id="layer-near"></g>

  <!-- Con trỏ chuột tùy chỉnh -->
  <circle id="cursor-glow" cx="-100" cy="-100" r="150" fill="url(#cursorGradient)" opacity="0.5" filter="url(#glow)"/>
  <circle id="cursor-core" cx="-100" cy="-100" r="3" fill="#ffffff" />

  <script type="text/javascript">
  //<![CDATA[
    const svg = document.querySelector("svg");
    const layers = {
      far: { g: document.getElementById("layer-far"), factor: 0.1, nodes: [], lines: [] },
      mid: { g: document.getElementById("layer-mid"), factor: 0.3, nodes: [], lines: [] },
      near: { g: document.getElementById("layer-near"), factor: 0.6, nodes: [], lines: [] }
    };
    
    const cursorGlow = document.getElementById("cursor-glow");
    const cursorCore = document.getElementById("cursor-core");

    const width = 1600;
    const height = 900;
    const centerX = width / 2;
    const centerY = height / 2;
    const interactionRadius = 200;

    const nodeCounts = { far: 100, mid: 50, near: 25 };
    const colors = {
      far: { node: "#306BAC", line: "#153d6b" },
      mid: { node: "#6930C3", line: "#49228a" },
      near: { node: "#00E5E5", line: "#008f8f" }
    };

    // Tạo các node và đường nối
    for (const key in layers) {
      const layer = layers[key];
      const count = nodeCounts[key];
      const color = colors[key];

      for (let i = 0; i < count; i++) {
        const node = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        const x = Math.random() * width;
        const y = Math.random() * height;
        const r = (key === 'near') ? 4 : (key === 'mid' ? 2.5 : 1.5);
        
        node.setAttribute("cx", x);
        node.setAttribute("cy", y);
        node.setAttribute("r", r);
        node.setAttribute("fill", color.node);
        node.setAttribute("opacity", 0.7);
        layer.g.appendChild(node);
        layer.nodes.push({ element: node, x, y, r, vx: (Math.random() - 0.5) * 0.1, vy: (Math.random() - 0.5) * 0.1 });
      }

      for (let i = 0; i < count; i++) {
        const startNode = layer.nodes[i];
        const endNode = layer.nodes[Math.floor(Math.random() * count)];
        const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
        line.setAttribute("x1", startNode.x);
        line.setAttribute("y1", startNode.y);
        line.setAttribute("x2", endNode.x);
        line.setAttribute("y2", endNode.y);
        line.setAttribute("stroke", color.line);
        line.setAttribute("stroke-width", (key === 'near') ? 1 : 0.5);
        line.setAttribute("opacity", 0.3);
        layer.g.appendChild(line);
        layer.lines.push({ element: line, start: startNode, end: endNode });
      }
    }

    let mouse = { x: -1000, y: -1000 };

    svg.addEventListener('mousemove', (e) => {
      const rect = svg.getBoundingClientRect();
      mouse.x = (e.clientX - rect.left) * (width / rect.width);
      mouse.y = (e.clientY - rect.top) * (height / rect.height);
      
      cursorGlow.setAttribute("cx", mouse.x);
      cursorGlow.setAttribute("cy", mouse.y);
      cursorCore.setAttribute("cx", mouse.x);
      cursorCore.setAttribute("cy", mouse.y);
    });
    
    svg.addEventListener('mouseleave', () => {
        mouse.x = -1000;
        mouse.y = -1000;
    });

    function animate() {
      // Hiệu ứng parallax
      const dx = mouse.x - centerX;
      const dy = mouse.y - centerY;

      for (const key in layers) {
        const layer = layers[key];
        const transX = -dx * layer.factor;
        const transY = -dy * layer.factor;
        layer.g.setAttribute("transform", `translate(${transX}, ${transY})`);

        // Tương tác và tự chuyển động
        layer.nodes.forEach(node => {
            // Tự chuyển động
            node.x += node.vx;
            node.y += node.vy;
            if (node.x < 0 || node.x > width) node.vx *= -1;
            if (node.y < 0 || node.y > height) node.vy *= -1;
            node.element.setAttribute("cx", node.x);
            node.element.setAttribute("cy", node.y);

            // Tương tác với chuột
            const nodeDistX = node.x - (mouse.x + dx * layer.factor);
            const nodeDistY = node.y - (mouse.y + dy * layer.factor);
            const dist = Math.sqrt(nodeDistX * nodeDistX + nodeDistY * nodeDistY);

            if (dist < interactionRadius) {
                const proximity = 1 - (dist / interactionRadius);
                node.element.setAttribute("r", node.r + proximity * 5);
                node.element.setAttribute("opacity", 0.7 + proximity * 0.3);
            } else {
                node.element.setAttribute("r", node.r);
                node.element.setAttribute("opacity", 0.7);
            }
        });

        // Cập nhật đường nối
        layer.lines.forEach(line => {
            line.element.setAttribute("x1", line.start.x);
            line.element.setAttribute("y1", line.start.y);
            line.element.setAttribute("x2", line.end.x);
            line.element.setAttribute("y2", line.end.y);

            // Tương tác đường nối
             const startDist = Math.sqrt(Math.pow(line.start.x - (mouse.x + dx * layer.factor), 2) + Math.pow(line.start.y - (mouse.y + dy * layer.factor), 2));
             const endDist = Math.sqrt(Math.pow(line.end.x - (mouse.x + dx * layer.factor), 2) + Math.pow(line.end.y - (mouse.y + dy * layer.factor), 2));
             if (startDist < interactionRadius || endDist < interactionRadius) {
                 const proximity = Math.max(1 - (startDist/interactionRadius), 1 - (endDist/interactionRadius));
                 line.element.setAttribute("opacity", 0.3 + proximity * 0.6);
                 line.element.setAttribute("stroke-width", ((key === 'near') ? 1 : 0.5) + proximity * 2);
             } else {
                 line.element.setAttribute("opacity", 0.3);
                 line.element.setAttribute("stroke-width", (key === 'near') ? 1 : 0.5);
             }
        });
      }

      requestAnimationFrame(animate);
    }
    animate();
  //]]>
  </script>
</svg>